<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–°–µ–∫—É–Ω–¥–æ–º–µ—Ä ‚Äî –ø—Ä–æ–±–µ–ª: —Å—Ç–∞—Ä—Ç ‚Üí —Å—Ç–æ–ø ‚Üí –∑–∞–ø–∏—Å—å</title>
  <style>
    :root {
      --bg: #0f1220;
      --card: #171a2b;
      --muted: #8a91b4;
      --text: #e9ecff;
      --accent: #7aa2ff;
      --ring: #2c3356;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 70% -10%, #1a1f3a 0%, var(--bg) 45%);
      color: var(--text);
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .wrap {
      width: min(880px, 100%);
      display: grid;
      gap: 18px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border: 1px solid var(--ring);
      border-radius: 16px;
      padding: 22px;
      box-shadow: var(--shadow);
    }
    .display {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .time {
      font-variant-numeric: tabular-nums lining-nums;
      font-weight: 700;
      letter-spacing: .5px;
      line-height: 1;
      font-size: clamp(40px, 10vw, 84px);
      user-select: none;
    }
    .badges {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .badge {
      border: 1px dashed var(--ring);
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 14px;
      backdrop-filter: blur(6px);
    }
    .controls { display:flex; gap:10px; flex-wrap: wrap; }
    .card-header { display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap; }
    .card-header .muted { margin-bottom:0 !important; }
    button {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--ring);
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
    }
    button:active { transform: translateY(1px); }
    button.primary { border-color: var(--accent); }

    table { width: 100%; border-collapse: collapse; }
    thead th {
      text-align: left;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--muted);
      padding: 10px 8px;
      border-bottom: 1px solid var(--ring);
    }
    tbody td {
      padding: 10px 8px;
      border-bottom: 1px dashed var(--ring);
    }
    tbody tr:last-child td { border-bottom: none; }
    .muted { color: var(--muted); }
      /* Row delete icon button */
    button.icon { background: transparent !important; border: none !important; box-shadow: none !important; padding: 4px 8px !important; border-radius: 8px !important; cursor: pointer; color: var(--muted); font-size: 16px; line-height: 1; }
    button.icon:hover { background: rgba(255,255,255,.06); color: #ff8a8a; }
    button.icon:active { transform: none !important; }
      /* Countdown overlay */
    .countdown-overlay { position:absolute; inset: 0; display:flex; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.12)); border-radius: 16px; pointer-events: none; }
    .countdown-digit { font-variant-numeric: tabular-nums; font-weight: 800; letter-spacing: .02em; font-size: clamp(48px, 15vw, 140px); color: var(--text); text-shadow: 0 4px 20px rgba(0,0,0,.45); }
    .controls .countdown { display:flex; align-items:center; gap:8px; color: var(--muted); border: 1px dashed var(--ring); padding: 8px 10px; border-radius: 12px; }
    .controls .countdown-prestart { margin-left: auto; }
    .controls .countdown input[type="range"] { accent-color: var(--accent); }
    .controls .countdown-min input { text-align: right; }
    .card { position: relative; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="display">
        <div id="time" class="time" aria-live="polite" aria-atomic="true">00:00:00.000</div>
        <div class="badges">
          <div class="badge">–ü—Ä–æ–±–µ–ª ‚Äî —Å—Ç–∞—Ä—Ç</div>
          <div class="badge">–ü—Ä–æ–±–µ–ª (–≤ –ø–∞—É–∑–µ) ‚Äî –∑–∞–ø–∏—Å—å –∏ —Å–±—Ä–æ—Å</div>
        </div>
      </div>
      <div class="controls" style="margin-top: 14px">
        <button id="btnToggle" class="primary" title="–ü—Ä–æ–±–µ–ª">‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç</button>
        <button id="btnReset" title="–ü—Ä–æ–±–µ–ª –ø–æ—Å–ª–µ –ø–∞—É–∑—ã">‚ü≤ –ó–∞–ø–∏—Å–∞—Ç—å –∏ —Å–±—Ä–æ—Å–∏—Ç—å</button>
        <button id="btnClear">üßπ –û—á–∏—Å—Ç–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É</button>
        <label class="countdown countdown-prestart" title="–û—Ç—Å—á—ë—Ç –∑–∞–ø—É—Å–∫–∞ (3, 5, 10 –∏–ª–∏ 15 —Å–µ–∫)">
          –û—Ç—Å—á—ë—Ç –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º:
          <input type="range" id="prestart" min="3" max="15" step="1" value="3" list="prestartMarks">
          <output id="prestartOut">3</output> —Å–µ–∫
        </label>
        <label class="countdown countdown-min" title="–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–ø—ã—Ç–∫–∏ –¥–ª—è –∑–∞–ø–∏—Å–∏">
          –ú–∏–Ω–∏–º—É–º –≤ —Ç–∞–±–ª–∏—Ü–µ:
          <input type="number" id="minRecord" min="0" max="3600" step="1" value="10" style="width:72px">
          —Å–µ–∫
        </label>
      </div>
      <div id="cdOverlay" class="countdown-overlay" hidden><div class="countdown-digit" id="cdText">3</div></div>
    </div>

    <datalist id="prestartMarks">
      <option value="3"></option>
      <option value="5"></option>
      <option value="10"></option>
      <option value="15"></option>
    </datalist>

    <div class="card" id="resultsCard">
      <div class="card-header" style="margin-bottom:8px">
        <div class="muted">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã (–∫–∞–∂–¥—ã–π —Ç—Ä–µ—Ç–∏–π –ø—Ä–æ–±–µ–ª –¥–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–ø–∏—Å—å):</div>
        <button id="btnDownload" type="button">üì∏ –°–∫–∞—á–∞—Ç—å —Å–∫—Ä–∏–Ω —Ç–∞–±–ª–∏—Ü—ã</button>
      </div>
      <table>
        <thead>
          <tr>
            <th style="width:80px">‚Ññ</th>
            <th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th>
            <th style="width:220px">–ú–µ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏</th>
            <th style="width:70px; text-align:center">√ó</th>
          </tr>
        </thead>
        <tbody id="results"></tbody>
      </table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" crossorigin="anonymous"></script>
  <script>
    // --- Stopwatch logic ---
    let running = false;
    let startTime = 0;      // perf.now() when started
    let elapsedMs = 0;      // accumulated time in ms
    let rafId = null;
    const timeEl = document.getElementById('time');
    const resultsEl = document.getElementById('results');
    const btnToggle = document.getElementById('btnToggle');
    const btnReset = document.getElementById('btnReset');
    const btnClear = document.getElementById('btnClear');
    const btnDownload = document.getElementById('btnDownload');
    const resultsCard = document.getElementById('resultsCard');
    const downloadBtnDefaultText = btnDownload ? btnDownload.textContent : '';

    const STORAGE_KEY = 'jpsw_results_v1';
    const SETTINGS_KEY = 'jpsw_settings_v1';
    let resultsData = [];
    let minRecordSeconds = 10;

    // Pre-start countdown controls
    const prestartRange = document.getElementById('prestart');
    const prestartOut = document.getElementById('prestartOut');
    const prestartAllowedValues = [3, 5, 10, 15];
    const cdOverlay = document.getElementById('cdOverlay');
    const cdText = document.getElementById('cdText');
    let isCountingDown = false;
    let cdRafId = null;
    let cdStart = 0;
    let cdDurationMs = 0;
    const minRecordInput = document.getElementById('minRecord');

    function clampPrestartValue(raw) {
      const numeric = Number(raw);
      if (!Number.isFinite(numeric)) return prestartAllowedValues[0];
      let closest = prestartAllowedValues[0];
      let minDiff = Math.abs(numeric - closest);
      for (let i = 1; i < prestartAllowedValues.length; i += 1) {
        const candidate = prestartAllowedValues[i];
        const diff = Math.abs(numeric - candidate);
        if (diff < minDiff) {
          minDiff = diff;
          closest = candidate;
        }
      }
      return closest;
    }

    function updatePrestartDisplay(value) {
      const snapped = clampPrestartValue(value);
      if (prestartRange) prestartRange.value = String(snapped);
      if (prestartOut) prestartOut.textContent = String(snapped);
    }

    if (prestartRange) {
      updatePrestartDisplay(prestartRange.value);
      prestartRange.addEventListener('input', (event) => {
        updatePrestartDisplay(event.target.value);
      });
      prestartRange.addEventListener('change', (event) => {
        updatePrestartDisplay(event.target.value);
      });
    }

    function pad(n, len=2) { return String(n).padStart(len, '0'); }
    function formatTime(ms) {
      ms = Math.max(0, Math.floor(ms));
      const milli = ms % 1000;
      const totalSec = Math.floor(ms / 1000);
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      return `${pad(h)}:${pad(m)}:${pad(s)}.${String(milli).padStart(3,'0')}`;
    }

    function render() {
      if (timeEl) timeEl.textContent = formatTime(elapsedMs);
    }

    function updatePrimaryButton() {
      if (!btnToggle) return;
      btnToggle.classList.remove('primary');
      if (running) {
        btnToggle.textContent = '‚è∏ –ü–∞—É–∑–∞';
        btnToggle.title = '–ü—Ä–æ–±–µ–ª';
      } else if (elapsedMs > 0) {
        btnToggle.textContent = 'üíæ –ó–∞–ø–∏—Å–∞—Ç—å –∏ —Å–±—Ä–æ—Å–∏—Ç—å';
        btnToggle.classList.add('primary');
        btnToggle.title = '–ü—Ä–æ–±–µ–ª (–∑–∞–ø–∏—Å–∞—Ç—å –∏ —Å–±—Ä–æ—Å–∏—Ç—å)';
      } else {
        btnToggle.textContent = '‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç';
        btnToggle.classList.add('primary');
        btnToggle.title = '–ü—Ä–æ–±–µ–ª';
      }
    }

    function tick(now) {
      elapsedMs = now - startTime;
      render();
      rafId = requestAnimationFrame(tick);
    }

    function start() {
      running = true;
      startTime = performance.now() - elapsedMs; // resume from paused value
      rafId = requestAnimationFrame(tick);
      updatePrimaryButton();
    }

    function pause() {
      running = false;
      if (rafId !== null) cancelAnimationFrame(rafId);
      rafId = null;
      render();
      updatePrimaryButton();
    }

    function handlePrimaryAction() {
      if (isCountingDown) {
        // Space during countdown: skip countdown and start immediately
        cancelCountdown();
        start();
        return;
      }
      if (!running && elapsedMs === 0) {
        const secs = prestartRange ? clampPrestartValue(prestartRange.value) : 0;
        if (secs && secs > 0) {
          beginCountdown(secs);
        } else {
          start();
        }
        return;
      }
      if (running) {
        pause();
        return;
      }
      resetAndLog();
    }

    function resetAndLog() {
      cancelCountdown();
      // Log current elapsed (even if 0), then reset to zero and pause
      addResultEntry(elapsedMs);
      elapsedMs = 0;
      pause();
    }

    function persistResults() {
      if (typeof localStorage === 'undefined') return;
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(resultsData));
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ localStorage', err);
      }
    }

    function formatStamp(stamp) {
      try {
        const stampDate = stamp ? new Date(stamp) : new Date();
        if (Number.isNaN(stampDate.getTime())) return '';
        const year = stampDate.getFullYear();
        const month = pad(stampDate.getMonth() + 1);
        const day = pad(stampDate.getDate());
        const hours = pad(stampDate.getHours());
        const minutes = pad(stampDate.getMinutes());
        const seconds = pad(stampDate.getSeconds());
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      } catch (err) {
        return stamp || '';
      }
    }

    function renderResults() {
      if (!resultsEl) return;
      resultsEl.innerHTML = '';
      const fragment = document.createDocumentFragment();
      const totalEntries = resultsData.length;
      resultsData.forEach((entry, index) => {
        const tr = document.createElement('tr');
        tr.dataset.index = String(index);

        const tdN = document.createElement('td');
        tdN.textContent = String(totalEntries - index);

        const tdTime = document.createElement('td');
        tdTime.textContent = formatTime(entry.ms);

        const tdStamp = document.createElement('td');
        tdStamp.textContent = formatStamp(entry.stamp);

        const tdDel = document.createElement('td');
        tdDel.style.textAlign = 'center';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'icon del';
        btn.setAttribute('aria-label', '–£–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É');
        btn.textContent = '√ó';
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(tr.dataset.index || '-1', 10);
          removeResult(idx);
        });
        tdDel.appendChild(btn);

        tr.appendChild(tdN);
        tr.appendChild(tdTime);
        tr.appendChild(tdStamp);
        tr.appendChild(tdDel);
        fragment.appendChild(tr);
      });
      resultsEl.appendChild(fragment);
    }

    function addResultEntry(ms) {
      const minMs = Math.max(0, Math.floor(minRecordSeconds * 1000));
      if (ms < minMs) {
        window.scrollTo(0, 0);
        renderResults();
        return;
      }
      const entry = {
        ms: Math.max(0, Math.floor(ms)),
        stamp: new Date().toISOString(),
      };
      resultsData.unshift(entry);
      persistResults();
      renderResults();
      window.scrollTo(0, 0);
    }

    function removeResult(index) {
      if (!Number.isInteger(index) || index < 0 || index >= resultsData.length) return;
      resultsData.splice(index, 1);
      persistResults();
      renderResults();
    }

    function clearResults() {
      resultsData = [];
      if (typeof localStorage !== 'undefined') {
        try {
          localStorage.removeItem(STORAGE_KEY);
        } catch (err) {
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ localStorage', err);
        }
      }
      renderResults();
    }

    function sanitizeStoredEntry(entry) {
      if (!entry || typeof entry !== 'object') return null;
      const ms = Number(entry.ms);
      if (!Number.isFinite(ms)) return null;
      const normalized = {
        ms: Math.max(0, Math.floor(ms)),
        stamp: typeof entry.stamp === 'string' ? entry.stamp : '',
      };
      return normalized;
    }

    function persistSettings() {
      if (typeof localStorage === 'undefined') return;
      const payload = {
        minRecordSeconds,
      };
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ localStorage', err);
      }
    }

    function restoreSettingsFromStorage() {
      if (typeof localStorage === 'undefined') {
        if (minRecordInput) minRecordInput.value = String(minRecordSeconds);
        return;
      }
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) {
          if (minRecordInput) minRecordInput.value = String(minRecordSeconds);
          return;
        }
        const parsed = JSON.parse(raw);
        const candidate = parsed && typeof parsed === 'object' ? Number(parsed.minRecordSeconds) : NaN;
        if (Number.isFinite(candidate) && candidate >= 0) {
          const clamped = Math.min(3600, candidate);
          minRecordSeconds = Math.round(clamped);
        }
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ localStorage', err);
      }
      if (minRecordInput) minRecordInput.value = String(minRecordSeconds);
    }

    function restoreResultsFromStorage() {
      if (typeof localStorage === 'undefined') {
        renderResults();
        return;
      }
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          renderResults();
          return;
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          renderResults();
          return;
        }
        const sanitized = parsed
          .map((item) => {
            try {
              return sanitizeStoredEntry(item);
            } catch (err) {
              return null;
            }
          })
          .filter(Boolean);
        sanitized.sort((a, b) => {
          const timeA = Date.parse(a.stamp || '') || 0;
          const timeB = Date.parse(b.stamp || '') || 0;
          return timeB - timeA;
        });
        resultsData = sanitized;
        renderResults();
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–∑ localStorage', err);
        resultsData = [];
        renderResults();
      }
    }

    async function downloadTableScreenshot() {
      if (!btnDownload || !resultsCard) return;
      if (typeof window.html2canvas !== 'function') {
        alert('–°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ html2canvas –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å.');
        return;
      }
      btnDownload.disabled = true;
      btnDownload.textContent = '‚è≥ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...';
      try {
        const canvas = await window.html2canvas(resultsCard, {
          backgroundColor: '#0f1220',
          scale: Math.min(window.devicePixelRatio || 1, 2),
          useCORS: true,
        });
        const link = document.createElement('a');
        const stamp = new Date().toISOString().replace(/[:.]/g, '-');
        link.download = `stopwatch-results-${stamp}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      } catch (err) {
        console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç —Ç–∞–±–ª–∏—Ü—ã', err);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
      } finally {
        btnDownload.disabled = false;
        btnDownload.textContent = downloadBtnDefaultText || 'üì∏ –°–∫–∞—á–∞—Ç—å —Å–∫—Ä–∏–Ω —Ç–∞–±–ª–∏—Ü—ã';
      }
    }

    function beginCountdown(secs) {
      if (!cdOverlay) { start(); return; }
      isCountingDown = true;
      cdDurationMs = Math.max(0, (secs|0) * 1000);
      cdStart = performance.now();
      cdOverlay.hidden = false;
      updateCountdownText(cdDurationMs);
      cdRafId = requestAnimationFrame(countdownTick);
    }
    function countdownTick(now) {
      const elapsed = now - cdStart;
      const remain = Math.max(0, cdDurationMs - elapsed);
      updateCountdownText(remain);
      if (remain <= 0) {
        cancelCountdown();
        start();
        return;
      }
      cdRafId = requestAnimationFrame(countdownTick);
    }
    function updateCountdownText(remainMs) {
      if (!cdText) return;
      // Show only 3..2..1 (no "–°—Ç–∞—Ä—Ç!" overlay to avoid sticking)
      if (remainMs <= 0) return;
      const remainingWhole = Math.max(1, Math.ceil(remainMs / 1000));
      cdText.textContent = String(remainingWhole);
    }
    function cancelCountdown() {
      if (!isCountingDown) return;
      isCountingDown = false;
      if (cdRafId !== null) cancelAnimationFrame(cdRafId);
      cdRafId = null;
      if (cdOverlay) { cdOverlay.hidden = true; }
      if (cdText) { cdText.textContent = ''; }
    }

    // --- Keyboard controls ---
    function isTypingTarget(el) {
      if (!el) return false;
      const tag = (el.tagName || '').toUpperCase();
      if (el.isContentEditable) return true;
      if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON') return true;
      return false;
    }
    window.addEventListener('keydown', (e) => {
      // Ignore key repeat to avoid flicker on long press
      if (e.repeat) return;
      // Ignore shortcuts when user interacts with inputs/controls (e.g., range slider)
      if (isTypingTarget(e.target)) return;
      if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault(); // prevent page scroll on space
        handlePrimaryAction();
      }
    }, { passive: false });

    restoreSettingsFromStorage();
    restoreResultsFromStorage();

    // --- Buttons as mouse fallback ---
    if (btnToggle) btnToggle.addEventListener('click', handlePrimaryAction);
    if (btnReset) btnReset.addEventListener('click', resetAndLog);
    if (btnClear) btnClear.addEventListener('click', clearResults);
    if (btnDownload) btnDownload.addEventListener('click', downloadTableScreenshot);

    if (minRecordInput) {
      minRecordInput.addEventListener('input', () => {
        const val = Number(minRecordInput.value);
        if (!Number.isFinite(val) || val < 0) return;
        const clamped = Math.min(3600, val);
        const rounded = Math.round(clamped);
        minRecordSeconds = rounded;
        minRecordInput.value = String(rounded);
        persistSettings();
      });
    }

    // Initial render
    render();
    updatePrimaryButton();
  </script>
</body>
</html>
