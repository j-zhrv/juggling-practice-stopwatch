
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–°–µ–∫—É–Ω–¥–æ–º–µ—Ä ‚Äî –ø—Ä–æ–±–µ–ª: —Å—Ç–∞—Ä—Ç ‚Üí —Å—Ç–æ–ø ‚Üí –∑–∞–ø–∏—Å—å</title>
  <style>
    :root {
      --bg: #0f1220;
      --card: #171a2b;
      --muted: #8a91b4;
      --text: #e9ecff;
      --accent: #7aa2ff;
      --ring: #2c3356;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 70% -10%, #1a1f3a 0%, var(--bg) 45%);
      color: var(--text);
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .wrap {
      width: min(880px, 100%);
      display: grid;
      gap: 18px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border: 1px solid var(--ring);
      border-radius: 16px;
      padding: 22px;
      box-shadow: var(--shadow);
    }
    .display {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .time {
      font-variant-numeric: tabular-nums lining-nums;
      font-weight: 700;
      letter-spacing: .5px;
      line-height: 1;
      font-size: clamp(40px, 10vw, 84px);
      user-select: none;
    }
    .badges {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .badge {
      border: 1px dashed var(--ring);
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 14px;
      backdrop-filter: blur(6px);
    }
    .controls { display:flex; gap:10px; flex-wrap: wrap; }
    .card-header { display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap; }
    .card-header .muted { margin-bottom:0 !important; }
    button {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--ring);
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
    }
    button:active { transform: translateY(1px); }
    button.primary { border-color: var(--accent); }

    select {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--ring);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 14px;
    }

    table { width: 100%; border-collapse: collapse; }
    thead th {
      text-align: left;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--muted);
      padding: 10px 8px;
      border-bottom: 1px solid var(--ring);
    }
    tbody td {
      padding: 10px 8px;
      border-bottom: 1px dashed var(--ring);
    }
    tbody tr:last-child td { border-bottom: none; }
    .muted { color: var(--muted); }
      /* Row delete icon button */
    button.icon { background: transparent !important; border: none !important; box-shadow: none !important; padding: 4px 8px !important; border-radius: 8px !important; cursor: pointer; color: var(--muted); font-size: 16px; line-height: 1; }
    button.icon:hover { background: rgba(255,255,255,.06); color: #ff8a8a; }
    button.icon:active { transform: none !important; }
      /* Countdown overlay */
    .countdown-overlay { position:absolute; inset: 0; display:flex; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.12)); border-radius: 16px; pointer-events: none; }
    .countdown-digit { font-variant-numeric: tabular-nums; font-weight: 800; letter-spacing: .02em; font-size: clamp(48px, 15vw, 140px); color: var(--text); text-shadow: 0 4px 20px rgba(0,0,0,.45); }
    .controls .countdown { display:flex; align-items:center; gap:8px; color: var(--muted); border: 1px dashed var(--ring); padding: 8px 10px; border-radius: 12px; }
    .controls .countdown-prestart { margin-left: auto; }
    .controls .countdown input[type="range"] { accent-color: var(--accent); }
    .controls .countdown-min input { text-align: right; }
    .card { position: relative; }

    .header-actions { display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .mode-bar { display:flex; flex-wrap:wrap; gap:16px; align-items:flex-end; justify-content:space-between; margin-top:16px; }
    .mode-selectors { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; }
    .mode-selectors label { display:flex; flex-direction:column; gap:6px; font-size:12px; color: var(--muted); }
    .mode-selectors select { min-width:140px; }
    .mode-summary { font-size:13px; color: var(--muted); margin-left:auto; align-self:center; flex:1 1 220px; text-align:right; }
    @media (max-width: 640px) {
      .mode-bar { flex-direction:column; align-items:stretch; }
      .mode-summary { margin-left:0; text-align:left; }
    }
    button#btnReset {
        display: none;
    }
    div#resultsCard {
        min-height: 600px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="display">
        <div class="time" aria-live="polite" aria-atomic="true">00:00</div>
        <div class="badges">
          <div class="badge">–ü—Ä–æ–±–µ–ª ‚Äî —Å—Ç–∞—Ä—Ç</div>
          <div class="badge">–ü—Ä–æ–±–µ–ª (–≤ –ø–∞—É–∑–µ) ‚Äî –∑–∞–ø–∏—Å—å –∏ —Å–±—Ä–æ—Å</div>
        </div>
      </div>
      <div class="mode-bar">
        <div class="mode-selectors">
          <label>
            <span>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º—è—á–µ–π</span>
            <select id="ballsMode">
              <option value="2">2 –º—è—á–∞</option>
              <option value="3">3 –º—è—á–∞</option>
              <option value="4">4 –º—è—á–∞</option>
            </select>
          </label>
          <label>
            <span>–†–µ–∂–∏–º —Ä—É–∫</span>
            <select id="handsMode">
              <option value="left">–¢–æ–ª—å–∫–æ –ª–µ–≤–æ–π</option>
              <option value="right">–¢–æ–ª—å–∫–æ –ø—Ä–∞–≤–æ–π</option>
              <option value="both">–î–≤—É–º—è —Ä—É–∫–∞–º–∏</option>
            </select>
          </label>
          <label>
            <span>–¢–∏–ø –∂–æ–Ω–≥–ª–∏—Ä–æ–≤–∞–Ω–∏—è</span>
            <select id="styleMode">
              <option value="clockwise">–ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ</option>
              <option value="counterclockwise">–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–∏</option>
              <option value="mixed">mixed</option>
              <option value="synchronous">—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ</option>
            </select>
          </label>
        </div>
        <div id="modeSummary" class="mode-summary"></div>
      </div>
      <div class="controls" style="margin-top: 14px">
        <button id="btnToggle" class="primary" title="–ü—Ä–æ–±–µ–ª">‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç</button>
        <button id="btnReset" title="–ü—Ä–æ–±–µ–ª –ø–æ—Å–ª–µ –ø–∞—É–∑—ã">‚ü≤ –ó–∞–ø–∏—Å–∞—Ç—å –∏ —Å–±—Ä–æ—Å–∏—Ç—å</button>
        <button id="btnClear">üßπ –û—á–∏—Å—Ç–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É</button>
        <label class="countdown countdown-prestart" title="–û—Ç—Å—á—ë—Ç –∑–∞–ø—É—Å–∫–∞ (3, 5, 10 –∏–ª–∏ 15 —Å–µ–∫)">
          –û—Ç—Å—á—ë—Ç –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º:
          <input type="range" id="prestart" min="3" max="15" step="1" value="3" list="prestartMarks">
          <output id="prestartOut">3</output> —Å–µ–∫
        </label>
        <label class="countdown countdown-min" title="–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–ø—ã—Ç–∫–∏ –¥–ª—è –∑–∞–ø–∏—Å–∏">
          –ú–∏–Ω–∏–º—É–º –≤ —Ç–∞–±–ª–∏—Ü–µ:
          <input type="number" id="minRecord" min="0" max="3600" step="1" value="10" style="width:72px">
          —Å–µ–∫
        </label>
      </div>
      <div id="cdOverlay" class="countdown-overlay" hidden><div class="countdown-digit" id="cdText">3</div></div>
    </div>

    <datalist id="prestartMarks">
      <option value="3"></option>
      <option value="5"></option>
      <option value="10"></option>
      <option value="15"></option>
    </datalist>

    <div class="card" id="resultsCard">
      <div class="card-header" style="margin-bottom:8px">
        <div class="muted">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã (–∫–∞–∂–¥—ã–π —Ç—Ä–µ—Ç–∏–π –ø—Ä–æ–±–µ–ª –¥–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–ø–∏—Å—å):</div>
        <div class="header-actions">
          <button id="btnDownload" type="button">üì∏ –°–∫–∞—á–∞—Ç—å —Å–∫—Ä–∏–Ω —Ç–∞–±–ª–∏—Ü—ã</button>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th style="width:80px">‚Ññ</th>
            <th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th>
            <th style="width:220px">–ú–µ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏</th>
            <th style="width:70px; text-align:center">√ó</th>
          </tr>
        </thead>
        <tbody id="results"></tbody>
      </table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" crossorigin="anonymous"></script>
  <script>
    // --- Stopwatch logic ---
    let running = false;
    let startTime = 0;      // perf.now() when started
    let elapsedMs = 0;      // accumulated time in ms
    let rafId = null;
    const timeEl = document.getElementById('time');
    const resultsEl = document.getElementById('results');
    const btnToggle = document.getElementById('btnToggle');
    const btnReset = document.getElementById('btnReset');
    const btnClear = document.getElementById('btnClear');
    const btnDownload = document.getElementById('btnDownload');
    const resultsCard = document.getElementById('resultsCard');
    const ballsSelect = document.getElementById('ballsMode');
    const handsSelect = document.getElementById('handsMode');
    const styleSelect = document.getElementById('styleMode');
    const modeSummaryEl = document.getElementById('modeSummary');
    const downloadBtnDefaultText = btnDownload ? btnDownload.textContent : '';

    const STORAGE_KEY = 'jpsw_results_v1';
    const SETTINGS_KEY = 'jpsw_settings_v1';
    const MODE_BALLS_OPTIONS = [2, 3, 4];
    const MODE_HAND_OPTIONS = [
      { value: 'left', label: '—Ç–æ–ª—å–∫–æ –ª–µ–≤–æ–π —Ä—É–∫–æ–π' },
      { value: 'right', label: '—Ç–æ–ª—å–∫–æ –ø—Ä–∞–≤–æ–π —Ä—É–∫–æ–π' },
      { value: 'both', label: '–¥–≤—É–º—è —Ä—É–∫–∞–º–∏' },
    ];
    const MODE_STYLE_OPTIONS = [
      { value: 'clockwise', label: '–ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ' },
      { value: 'counterclockwise', label: '–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–∏' },
      { value: 'mixed', label: 'mixed' },
      { value: 'synchronous', label: '—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ' },
    ];
    const MODE_DEFAULT_BALLS = 3;
    const MODE_DEFAULT_HANDS = 'both';
    const MODE_DEFAULT_STYLE = 'mixed';
    let selectedBalls = MODE_DEFAULT_BALLS;
    let selectedHands = MODE_DEFAULT_HANDS;
    let selectedStyle = MODE_DEFAULT_STYLE;
    let allResultsByMode = {};
    let minRecordSeconds = 10;

    // Pre-start countdown controls
    const prestartRange = document.getElementById('prestart');
    const prestartOut = document.getElementById('prestartOut');
    const prestartAllowedValues = [3, 5, 10, 15];
    const cdOverlay = document.getElementById('cdOverlay');
    const cdText = document.getElementById('cdText');
    let isCountingDown = false;
    let cdRafId = null;
    let cdStart = 0;
    let cdDurationMs = 0;
    const minRecordInput = document.getElementById('minRecord');

    function clampPrestartValue(raw) {
      const numeric = Number(raw);
      if (!Number.isFinite(numeric)) return prestartAllowedValues[0];
      let closest = prestartAllowedValues[0];
      let minDiff = Math.abs(numeric - closest);
      for (let i = 1; i < prestartAllowedValues.length; i += 1) {
        const candidate = prestartAllowedValues[i];
        const diff = Math.abs(numeric - candidate);
        if (diff < minDiff) {
          minDiff = diff;
          closest = candidate;
        }
      }
      return closest;
    }

    function updatePrestartDisplay(value) {
      const snapped = clampPrestartValue(value);
      if (prestartRange) prestartRange.value = String(snapped);
      if (prestartOut) prestartOut.textContent = String(snapped);
    }

    function buildModeKey(balls, hands, style) {
      return `${balls}b_${hands}_${style}`;
    }

    function isValidBalls(value) {
      return MODE_BALLS_OPTIONS.includes(value);
    }

    function isValidHands(value) {
      return MODE_HAND_OPTIONS.some((opt) => opt.value === value);
    }

    function isValidStyle(value) {
      return MODE_STYLE_OPTIONS.some((opt) => opt.value === value);
    }

    function parseModeKey(key) {
      if (typeof key !== 'string') return null;
      const match = key.match(/^(\d+)b_([a-z]+)(?:_([a-z]+))?$/i);
      if (!match) return null;
      const balls = Number(match[1]);
      const hands = match[2].toLowerCase();
      const style = (match[3] ? match[3].toLowerCase() : MODE_DEFAULT_STYLE);
      if (!isValidBalls(balls) || !isValidHands(hands) || !isValidStyle(style)) {
        return null;
      }
      return { balls, hands, style };
    }

    function getBallsLabel(count) {
      const abs = Math.abs(count);
      const mod10 = abs % 10;
      const mod100 = abs % 100;
      let word = '–º—è—á–µ–π';
      if (mod10 === 1 && mod100 !== 11) {
        word = '–º—è—á';
      } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
        word = '–º—è—á–∞';
      }
      return `${count} ${word}`;
    }

    function getHandsLabel(value) {
      switch (value) {
        case 'left':
          return '—Ç–æ–ª—å–∫–æ –ª–µ–≤–æ–π —Ä—É–∫–æ–π';
        case 'right':
          return '—Ç–æ–ª—å–∫–æ –ø—Ä–∞–≤–æ–π —Ä—É–∫–æ–π';
        case 'both':
          return '–¥–≤—É–º—è —Ä—É–∫–∞–º–∏';
        default:
          return value;
      }
    }

    function getStyleLabel(value) {
      const match = MODE_STYLE_OPTIONS.find((opt) => opt.value === value);
      return match ? match.label : value;
    }

    function getOrCreateModeData(balls, hands, style) {
      const key = buildModeKey(balls, hands, style);
      if (!allResultsByMode[key]) {
        allResultsByMode[key] = [];
      }
      return allResultsByMode[key];
    }

    function getCurrentModeData() {
      return getOrCreateModeData(selectedBalls, selectedHands, selectedStyle);
    }

    function updateModeSummary() {
      if (!modeSummaryEl) return;
      const ballsText = getBallsLabel(selectedBalls);
      const handsText = getHandsLabel(selectedHands);
      const styleText = getStyleLabel(selectedStyle);
      modeSummaryEl.textContent = `–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º: ${ballsText} ¬∑ ${handsText} ¬∑ ${styleText}`;
    }

    function applyModeToControls() {
      if (ballsSelect) {
        ballsSelect.value = String(selectedBalls);
      }
      if (handsSelect) {
        handsSelect.value = selectedHands;
      }
      if (styleSelect) {
        styleSelect.value = selectedStyle;
      }
    }

    function switchMode(newBalls, newHands, newStyle) {
      if (!isValidBalls(newBalls) || !isValidHands(newHands) || !isValidStyle(newStyle)) {
        return;
      }
      if (newBalls === selectedBalls && newHands === selectedHands && newStyle === selectedStyle) {
        return;
      }
      selectedBalls = newBalls;
      selectedHands = newHands;
      selectedStyle = newStyle;
      applyModeToControls();
      updateModeSummary();
      renderResults();
      persistSettings();
      persistResults();
    }

    if (prestartRange) {
      updatePrestartDisplay(prestartRange.value);
      prestartRange.addEventListener('input', (event) => {
        updatePrestartDisplay(event.target.value);
      });
      prestartRange.addEventListener('change', (event) => {
        updatePrestartDisplay(event.target.value);
      });
    }

    function pad(n, len=2) { return String(n).padStart(len, '0'); }
    function formatTime(ms) {
      ms = Math.max(0, Math.floor(ms));
      const totalSec = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSec / 60);   // –º–∏–Ω—É—Ç—ã –Ω–∞–∫–∞–ø–ª–∏–≤–∞—é—Ç—Å—è: 0,1,2,‚Ä¶,120‚Ä¶
      const seconds = totalSec % 60;
      return `${pad(minutes)}:${pad(seconds)}`;
    }

    function render() {
      if (timeEl) timeEl.textContent = formatTime(elapsedMs);
    }

    function updatePrimaryButton() {
      if (!btnToggle) return;
      btnToggle.classList.remove('primary');
      if (running) {
        btnToggle.textContent = '‚è∏ –ü–∞—É–∑–∞';
        btnToggle.title = '–ü—Ä–æ–±–µ–ª';
      } else if (elapsedMs > 0) {
        btnToggle.textContent = 'üíæ –ó–∞–ø–∏—Å–∞—Ç—å –∏ —Å–±—Ä–æ—Å–∏—Ç—å';
        btnToggle.classList.add('primary');
        btnToggle.title = '–ü—Ä–æ–±–µ–ª (–∑–∞–ø–∏—Å–∞—Ç—å –∏ —Å–±—Ä–æ—Å–∏—Ç—å)';
      } else {
        btnToggle.textContent = '‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç';
        btnToggle.classList.add('primary');
        btnToggle.title = '–ü—Ä–æ–±–µ–ª';
      }
    }

    function tick(now) {
      elapsedMs = now - startTime;
      render();
      rafId = requestAnimationFrame(tick);
    }

    function start() {
      running = true;
      startTime = performance.now() - elapsedMs; // resume from paused value
      rafId = requestAnimationFrame(tick);
      updatePrimaryButton();
    }

    function pause() {
      running = false;
      if (rafId !== null) cancelAnimationFrame(rafId);
      rafId = null;
      render();
      updatePrimaryButton();
    }

    function handlePrimaryAction() {
      if (isCountingDown) {
        // Space during countdown: skip countdown and start immediately
        cancelCountdown();
        start();
        return;
      }
      if (!running && elapsedMs === 0) {
        const secs = prestartRange ? clampPrestartValue(prestartRange.value) : 0;
        if (secs && secs > 0) {
          beginCountdown(secs);
        } else {
          start();
        }
        return;
      }
      if (running) {
        pause();
        return;
      }
      resetAndLog();
    }

    function resetAndLog() {
      cancelCountdown();
      // Log current elapsed (even if 0), then reset to zero and pause
      addResultEntry(elapsedMs);
      elapsedMs = 0;
      pause();
    }

    function persistResults() {
      if (typeof localStorage === 'undefined') return;
      try {
        const payload = {};
        Object.keys(allResultsByMode).forEach((key) => {
          const arr = allResultsByMode[key];
          if (!Array.isArray(arr) || arr.length === 0) return;
          const sanitized = arr
            .map((item) => {
              try {
                return sanitizeStoredEntry(item);
              } catch (err) {
                return null;
              }
            })
            .filter(Boolean);
          if (sanitized.length > 0) {
            payload[key] = sanitized;
          }
        });
        const modeKeys = Object.keys(payload);
        if (modeKeys.length === 0) {
          localStorage.removeItem(STORAGE_KEY);
        } else {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        }
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ localStorage', err);
      }
    }

    function formatStamp(stamp) {
      try {
        const stampDate = stamp ? new Date(stamp) : new Date();
        if (Number.isNaN(stampDate.getTime())) return '';
        const year = stampDate.getFullYear();
        const month = pad(stampDate.getMonth() + 1);
        const day = pad(stampDate.getDate());
        const hours = pad(stampDate.getHours());
        const minutes = pad(stampDate.getMinutes());
        const seconds = pad(stampDate.getSeconds());
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      } catch (err) {
        return stamp || '';
      }
    }

    function renderResults() {
      if (!resultsEl) return;
      resultsEl.innerHTML = '';
      const fragment = document.createDocumentFragment();
      const modeData = getCurrentModeData();
      const totalEntries = modeData.length;
      modeData.forEach((entry, index) => {
        const tr = document.createElement('tr');
        tr.dataset.index = String(index);

        const tdN = document.createElement('td');
        tdN.textContent = String(totalEntries - index);

        const tdTime = document.createElement('td');
        tdTime.textContent = formatTime(entry.ms);

        const tdStamp = document.createElement('td');
        tdStamp.textContent = formatStamp(entry.stamp);

        const tdDel = document.createElement('td');
        tdDel.style.textAlign = 'center';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'icon del';
        btn.setAttribute('aria-label', '–£–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É');
        btn.textContent = '√ó';
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(tr.dataset.index || '-1', 10);
          removeResult(idx);
        });
        tdDel.appendChild(btn);

        tr.appendChild(tdN);
        tr.appendChild(tdTime);
        tr.appendChild(tdStamp);
        tr.appendChild(tdDel);
        fragment.appendChild(tr);
      });
      resultsEl.appendChild(fragment);
    }

    function addResultEntry(ms) {
      const minMs = Math.max(0, Math.floor(minRecordSeconds * 1000));
      if (ms < minMs) {
        window.scrollTo(0, 0);
        renderResults();
        return;
      }
      const entry = {
        ms: Math.max(0, Math.floor(ms)),
        stamp: new Date().toISOString(),
      };
      const modeData = getCurrentModeData();
      modeData.unshift(entry);
      persistResults();
      renderResults();
      window.scrollTo(0, 0);
    }

    function removeResult(index) {
      const modeData = getCurrentModeData();
      if (!Number.isInteger(index) || index < 0 || index >= modeData.length) return;
      modeData.splice(index, 1);
      persistResults();
      renderResults();
    }

    function clearResults() {
      const modeData = getCurrentModeData();
      modeData.splice(0, modeData.length);
      persistResults();
      renderResults();
    }

    function sanitizeStoredEntry(entry) {
      if (!entry || typeof entry !== 'object') return null;
      const ms = Number(entry.ms);
      if (!Number.isFinite(ms)) return null;
      const normalized = {
        ms: Math.max(0, Math.floor(ms)),
        stamp: typeof entry.stamp === 'string' ? entry.stamp : '',
      };
      return normalized;
    }

    function sanitizeStoredArray(arr) {
      if (!Array.isArray(arr)) return [];
      const sanitized = arr
        .map((item) => {
          try {
            return sanitizeStoredEntry(item);
          } catch (err) {
            return null;
          }
        })
        .filter(Boolean);
      sanitized.sort((a, b) => {
        const timeA = Date.parse(a.stamp || '') || 0;
        const timeB = Date.parse(b.stamp || '') || 0;
        return timeB - timeA;
      });
      return sanitized;
    }

    function persistSettings() {
      if (typeof localStorage === 'undefined') return;
      const payload = {
        minRecordSeconds,
        selectedBalls,
        selectedHands,
        selectedStyle,
      };
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ localStorage', err);
      }
    }

    function restoreSettingsFromStorage() {
      selectedBalls = MODE_DEFAULT_BALLS;
      selectedHands = MODE_DEFAULT_HANDS;
      selectedStyle = MODE_DEFAULT_STYLE;
      if (typeof localStorage === 'undefined') {
        if (minRecordInput) minRecordInput.value = String(minRecordSeconds);
        return;
      }
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) {
          if (minRecordInput) minRecordInput.value = String(minRecordSeconds);
          return;
        }
        const parsed = JSON.parse(raw);
        const candidate = parsed && typeof parsed === 'object' ? Number(parsed.minRecordSeconds) : NaN;
        if (Number.isFinite(candidate) && candidate >= 0) {
          const clamped = Math.min(3600, candidate);
          minRecordSeconds = Math.round(clamped);
        }
        if (parsed && typeof parsed === 'object') {
          const candidateBalls = Number(parsed.selectedBalls);
          if (Number.isFinite(candidateBalls) && isValidBalls(candidateBalls)) {
            selectedBalls = candidateBalls;
          }
          const candidateHands = typeof parsed.selectedHands === 'string' ? parsed.selectedHands : '';
          if (isValidHands(candidateHands)) {
            selectedHands = candidateHands;
          }
          const candidateStyle = typeof parsed.selectedStyle === 'string' ? parsed.selectedStyle : '';
          if (isValidStyle(candidateStyle)) {
            selectedStyle = candidateStyle;
          }
        }
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ localStorage', err);
      }
      if (minRecordInput) minRecordInput.value = String(minRecordSeconds);
    }

    function restoreResultsFromStorage() {
      allResultsByMode = {};
      if (typeof localStorage === 'undefined') {
        renderResults();
        return;
      }
      let shouldPersist = false;
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            const sanitized = sanitizeStoredArray(parsed);
            const legacyKey = buildModeKey(MODE_DEFAULT_BALLS, MODE_DEFAULT_HANDS, MODE_DEFAULT_STYLE);
            allResultsByMode[legacyKey] = sanitized;
            shouldPersist = true;
          } else if (parsed && typeof parsed === 'object') {
            Object.keys(parsed).forEach((key) => {
              try {
                const sanitized = sanitizeStoredArray(parsed[key]);
                const parsedKey = parseModeKey(key);
                const target = parsedKey
                  ? buildModeKey(parsedKey.balls, parsedKey.hands, parsedKey.style)
                  : buildModeKey(MODE_DEFAULT_BALLS, MODE_DEFAULT_HANDS, MODE_DEFAULT_STYLE);
                allResultsByMode[target] = sanitized;
                if (!parsedKey || target !== key) {
                  shouldPersist = true;
                }
              } catch (err) {
                // ignore malformed entries
              }
            });
          }
        }
      } catch (err) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–∑ localStorage', err);
        allResultsByMode = {};
      }
      renderResults();
      if (shouldPersist) {
        persistResults();
      }
    }

    async function downloadTableScreenshot() {
      if (!btnDownload || !resultsCard) return;
      if (typeof window.html2canvas !== 'function') {
        alert('–°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ html2canvas –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å.');
        return;
      }
      btnDownload.disabled = true;
      btnDownload.textContent = '‚è≥ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...';
      try {
        const canvas = await window.html2canvas(resultsCard, {
          backgroundColor: '#0f1220',
          scale: Math.min(window.devicePixelRatio || 1, 2),
          useCORS: true,
        });
        const link = document.createElement('a');
        const stamp = new Date().toISOString().replace(/[:.]/g, '-');
        const modeKey = buildModeKey(selectedBalls, selectedHands, selectedStyle);
        link.download = `stopwatch-results-${modeKey}-${stamp}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      } catch (err) {
        console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç —Ç–∞–±–ª–∏—Ü—ã', err);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
      } finally {
        btnDownload.disabled = false;
        btnDownload.textContent = downloadBtnDefaultText || 'üì∏ –°–∫–∞—á–∞—Ç—å —Å–∫—Ä–∏–Ω —Ç–∞–±–ª–∏—Ü—ã';
      }
    }

    function beginCountdown(secs) {
      if (!cdOverlay) { start(); return; }
      isCountingDown = true;
      cdDurationMs = Math.max(0, (secs|0) * 1000);
      cdStart = performance.now();
      cdOverlay.hidden = false;
      updateCountdownText(cdDurationMs);
      cdRafId = requestAnimationFrame(countdownTick);
    }
    function countdownTick(now) {
      const elapsed = now - cdStart;
      const remain = Math.max(0, cdDurationMs - elapsed);
      updateCountdownText(remain);
      if (remain <= 0) {
        cancelCountdown();
        start();
        return;
      }
      cdRafId = requestAnimationFrame(countdownTick);
    }
    function updateCountdownText(remainMs) {
      if (!cdText) return;
      // Show only 3..2..1 (no "–°—Ç–∞—Ä—Ç!" overlay to avoid sticking)
      if (remainMs <= 0) return;
      const remainingWhole = Math.max(1, Math.ceil(remainMs / 1000));
      cdText.textContent = String(remainingWhole);
    }
    function cancelCountdown() {
      if (!isCountingDown) return;
      isCountingDown = false;
      if (cdRafId !== null) cancelAnimationFrame(cdRafId);
      cdRafId = null;
      if (cdOverlay) { cdOverlay.hidden = true; }
      if (cdText) { cdText.textContent = ''; }
    }

    // --- Keyboard controls ---
    function isTypingTarget(el) {
      if (!el) return false;
      const tag = (el.tagName || '').toUpperCase();
      if (el.isContentEditable) return true;
      if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON') return true;
      return false;
    }
    window.addEventListener('keydown', (e) => {
      // Ignore key repeat to avoid flicker on long press
      if (e.repeat) return;
      // Ignore shortcuts when user interacts with inputs/controls (e.g., range slider)
      if (isTypingTarget(e.target)) return;
      if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault(); // prevent page scroll on space
        handlePrimaryAction();
      }
    }, { passive: false });

    restoreSettingsFromStorage();
    applyModeToControls();
    restoreResultsFromStorage();
    updateModeSummary();

    // --- Buttons as mouse fallback ---
    if (btnToggle) btnToggle.addEventListener('click', handlePrimaryAction);
    if (btnReset) btnReset.addEventListener('click', resetAndLog);
    if (btnClear) btnClear.addEventListener('click', clearResults);
    if (btnDownload) btnDownload.addEventListener('click', downloadTableScreenshot);

    if (ballsSelect) {
      ballsSelect.addEventListener('change', () => {
        const val = Number(ballsSelect.value);
        if (Number.isFinite(val) && isValidBalls(val)) {
          switchMode(val, selectedHands, selectedStyle);
        } else {
          applyModeToControls();
        }
      });
    }

    if (handsSelect) {
      handsSelect.addEventListener('change', () => {
        const val = handsSelect.value;
        if (isValidHands(val)) {
          switchMode(selectedBalls, val, selectedStyle);
        } else {
          applyModeToControls();
        }
      });
    }

    if (styleSelect) {
      styleSelect.addEventListener('change', () => {
        const val = styleSelect.value;
        if (isValidStyle(val)) {
          switchMode(selectedBalls, selectedHands, val);
        } else {
          applyModeToControls();
        }
      });
    }

    if (minRecordInput) {
      minRecordInput.addEventListener('input', () => {
        const val = Number(minRecordInput.value);
        if (!Number.isFinite(val) || val < 0) return;
        const clamped = Math.min(3600, val);
        const rounded = Math.round(clamped);
        minRecordSeconds = rounded;
        minRecordInput.value = String(rounded);
        persistSettings();
      });
    }

    // Initial render
    render();
    updatePrimaryButton();
  </script>
</body>
</html>
